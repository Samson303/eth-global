"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ContractBase = void 0;
const ContractHandler_1 = __importDefault(require("../ContractHandler"));
const Instantiable_abstract_1 = require("../../Instantiable.abstract");
class ContractBase extends Instantiable_abstract_1.Instantiable {
    constructor(contractName, optional = false) {
        super();
        this.optional = optional;
        this.contract = null;
        this.contractName = contractName;
    }
    get address() {
        return this.contract.options.address;
    }
    getEventData(eventName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.contract.events[eventName]) {
                throw new Error(`Event "${eventName}" not found on contract "${this.contractName}"`);
            }
            return this.contract.getPastEvents(eventName, options);
        });
    }
    getPastEvents(eventName, filter) {
        return this.getEventData(eventName, {
            filter,
            fromBlock: 0,
            toBlock: 'latest'
        });
    }
    getAddress() {
        return this.contract.options.address;
    }
    getSignatureOfMethod(methodName) {
        const foundMethod = this.searchMethod(methodName);
        return foundMethod.signature;
    }
    getInputsOfMethod(methodName) {
        const foundMethod = this.searchMethod(methodName);
        return foundMethod.inputs;
    }
    init(config) {
        return __awaiter(this, void 0, void 0, function* () {
            this.setInstanceConfig(config);
            const contractHandler = new ContractHandler_1.default(config);
            this.contract = yield contractHandler.get(this.contractName, this.optional);
        });
    }
    getFromAddress(from) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!from) {
                from = (yield this.web3.eth.getAccounts())[0];
            }
            return from;
        });
    }
    sendFrom(name, args, from) {
        return __awaiter(this, void 0, void 0, function* () {
            from = yield this.getFromAddress(from);
            return this.send(name, from, args);
        });
    }
    send(name, from, args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.contract.methods[name]) {
                throw new Error(`Method "${name}" is not part of contract "${this.contractName}"`);
            }
            const method = this.contract.methods[name];
            try {
                const methodInstance = method(...args);
                const gas = yield methodInstance.estimateGas(args, {
                    from
                });
                const tx = methodInstance.send({
                    from,
                    gas
                });
                return tx;
            }
            catch (err) {
                const mappedArgs = this.searchMethod(name, args).inputs.map((input, i) => {
                    return {
                        name: input.name,
                        value: args[i]
                    };
                });
                this.logger.error('-'.repeat(40));
                this.logger.error(`Sending transaction "${name}" on contract "${this.contractName}" failed.`);
                this.logger.error(`Error: ${err.message}`);
                this.logger.error(`From: ${from}`);
                this.logger.error(`Parameters: ${JSON.stringify(mappedArgs, null, 2)}`);
                this.logger.error('-'.repeat(40));
                throw err;
            }
        });
    }
    call(name, args, from) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.contract.methods[name]) {
                throw new Error(`Method ${name} is not part of contract ${this.contractName}`);
            }
            try {
                const method = this.contract.methods[name](...args);
                return method.call(from ? { from } : null);
            }
            catch (err) {
                this.logger.error(`Calling method "${name}" on contract "${this.contractName}" failed. Args: ${args}`, err);
                throw err;
            }
        });
    }
    getEvent(eventName, filter) {
        if (!this.contract.events[eventName]) {
            throw new Error(`Event ${eventName} is not part of contract ${this.contractName}`);
        }
        return this.nevermined.keeper.utils.eventHandler.getEvent(this, eventName, filter);
    }
    searchMethod(methodName, args = []) {
        const methods = this.contract.options.jsonInterface
            .map(method => (Object.assign(Object.assign({}, method), { signature: method.signature })))
            .filter((method) => method.name === methodName);
        const foundMethod = methods.find(({ inputs }) => inputs.length === args.length) || methods[0];
        if (!foundMethod) {
            throw new Error(`Method "${methodName}" is not part of contract "${this.contractName}"`);
        }
        return foundMethod;
    }
}
exports.ContractBase = ContractBase;
ContractBase.instance = null;
exports.default = ContractBase;
//# sourceMappingURL=ContractBase.js.map