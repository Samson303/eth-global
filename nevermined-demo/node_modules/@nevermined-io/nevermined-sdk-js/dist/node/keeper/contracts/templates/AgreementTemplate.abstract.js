"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgreementTemplate = void 0;
const ContractBase_1 = __importDefault(require("../ContractBase"));
const Condition_abstract_1 = require("../conditions/Condition.abstract");
const utils_1 = require("../../../utils");
class AgreementTemplate extends ContractBase_1.default {
    static getInstance(config, conditionName, templateClass) {
        return __awaiter(this, void 0, void 0, function* () {
            const condition = new templateClass(conditionName);
            yield condition.init(config);
            return condition;
        });
    }
    constructor(contractName) {
        super(contractName);
    }
    createAgreement(agreementId, did, conditionIds, timeLocks, timeOuts, extraArgs, from) {
        return this.sendFrom('createAgreement', [
            utils_1.zeroX(agreementId),
            utils_1.zeroX(did),
            conditionIds.map(utils_1.zeroX),
            timeLocks,
            timeOuts,
            ...extraArgs
        ], from);
    }
    getConditionTypes() {
        return this.call('getConditionTypes', []);
    }
    getConditions() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getConditionTypes()).map(address => this.nevermined.keeper.getConditionByAddress(address));
        });
    }
    getServiceAgreementTemplateConditions() {
        return __awaiter(this, void 0, void 0, function* () {
            const serviceAgreementTemplate = yield this.getServiceAgreementTemplate();
            return serviceAgreementTemplate.conditions;
        });
    }
    getServiceAgreementTemplateConditionByRef(ref) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = (yield this.getServiceAgreementTemplateConditions()).find(({ name: conditionRef }) => conditionRef === ref).contractName;
            return (yield this.getConditions()).find(condition => condition.contractName === name);
        });
    }
    getServiceAgreementTemplateDependencies() {
        return __awaiter(this, void 0, void 0, function* () {
            const serviceAgreementTemplate = yield this.getServiceAgreementTemplate();
            return serviceAgreementTemplate.conditionDependency;
        });
    }
    getAgreementStatus(agreementId) {
        return __awaiter(this, void 0, void 0, function* () {
            const agreementStore = this.nevermined.keeper.agreementStoreManager;
            const conditionStore = this.nevermined.keeper.conditionStoreManager;
            const dependencies = yield this.getServiceAgreementTemplateDependencies();
            const { conditionIds } = yield agreementStore.getAgreement(agreementId);
            if (!conditionIds.length) {
                this.logger.error(`Agreement not creeated yet: "${agreementId}"`);
                return false;
            }
            const conditionIdByConddition = (yield this.getConditions()).reduce((acc, { contractName }, i) => (Object.assign(Object.assign({}, acc), { [contractName]: conditionIds[i] })), {});
            const statesPromises = Object.keys(dependencies).map((ref, i) => __awaiter(this, void 0, void 0, function* () {
                const { contractName } = yield this.getServiceAgreementTemplateConditionByRef(ref);
                return {
                    ref,
                    contractName,
                    state: (yield conditionStore.getCondition(conditionIdByConddition[contractName])).state
                };
            }));
            const states = yield Promise.all(statesPromises);
            return states.reduce((acc, { contractName, ref, state }) => {
                const blockers = dependencies[ref]
                    .map(dependency => states.find(_ => _.ref === dependency))
                    .filter(condition => condition.state !== Condition_abstract_1.ConditionState.Fulfilled);
                return Object.assign(Object.assign({}, acc), { [ref]: {
                        condition: ref,
                        contractName,
                        state,
                        blocked: !!blockers.length,
                        blockedBy: blockers.map(_ => _.ref)
                    } });
            }, {});
        });
    }
    printAgreementStatus(agreementId) {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.getAgreementStatus(agreementId);
            this.logger.bypass('-'.repeat(80));
            this.logger.bypass('Template:', this.contractName);
            this.logger.bypass('Agreement ID:', agreementId);
            this.logger.bypass('-'.repeat(40));
            if (!status) {
                this.logger.bypass('Agreement not created yet!');
            }
            Object.values(status || []).forEach(({ condition, contractName, state, blocked, blockedBy }, i) => {
                if (i) {
                    this.logger.bypass('-'.repeat(20));
                }
                this.logger.bypass(`${condition} (${contractName})`);
                this.logger.bypass('  Status:', state, `(${Condition_abstract_1.conditionStateNames[state]})`);
                if (blocked) {
                    this.logger.bypass('  Blocked by:', blockedBy);
                }
            });
            this.logger.bypass('-'.repeat(80));
        });
    }
    getAgreementCreatedEvent(agreementId) {
        return this.getEvent('AgreementCreated', {
            agreementId: utils_1.zeroX(agreementId)
        });
    }
}
exports.AgreementTemplate = AgreementTemplate;
//# sourceMappingURL=AgreementTemplate.abstract.js.map