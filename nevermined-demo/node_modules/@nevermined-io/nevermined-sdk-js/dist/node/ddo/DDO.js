"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DDO = void 0;
const Web3Provider_1 = __importDefault(require("../keeper/Web3Provider"));
const utils_1 = require("../utils");
class DDO {
    constructor(ddo = {}) {
        this['@context'] = 'https://w3id.org/did/v1';
        this.id = null;
        this.publicKey = [];
        this.authentication = [];
        this.service = [];
        Object.assign(this, ddo, {
            created: (ddo && ddo.created) || new Date().toISOString().replace(/\.[0-9]{3}/, ''),
        });
    }
    static serialize(ddo) {
        return JSON.stringify(ddo, null, 2);
    }
    static deserialize(ddoString) {
        const ddo = JSON.parse(ddoString);
        return new DDO(ddo);
    }
    shortId() {
        return this.id.replace('did:nv:', '');
    }
    findServiceById(index) {
        if (isNaN(index)) {
            throw new Error('index is not set');
        }
        const service = this.service.find(s => s.index === index);
        return service;
    }
    findServiceByType(serviceType) {
        if (!serviceType) {
            throw new Error('serviceType not set');
        }
        return this.service.find(s => s.type === serviceType);
    }
    checksum(seed) {
        return Web3Provider_1.default.getWeb3()
            .utils.sha3(seed)
            .replace(/^0x([a-f0-9]{64})(:!.+)?$/i, '0x$1');
    }
    generateProof(nevermined, publicKey, password) {
        return __awaiter(this, void 0, void 0, function* () {
            const checksum = {};
            this.service.forEach(svc => {
                checksum[svc.index] = this.checksum(JSON.stringify(this.findServiceByType(svc.type).attributes.main));
            });
            return {
                created: new Date().toISOString().replace(/\.[0-9]{3}/, ''),
                creator: publicKey,
                type: 'DDOIntegritySignature',
                signatureValue: '',
                checksum,
            };
        });
    }
    addProof(nevermined, publicKey, password) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.proof) {
                throw new Error('Proof already exists');
            }
            this.proof = yield this.generateProof(nevermined, publicKey, password);
        });
    }
    addService(nevermined, service) {
        return __awaiter(this, void 0, void 0, function* () {
            this.service.push(service);
        });
    }
    updateService(nevermined, service) {
        return __awaiter(this, void 0, void 0, function* () {
            this.service[0] = service;
        });
    }
    assignDid(checksum) {
        return __awaiter(this, void 0, void 0, function* () {
            const didFromChecksum = yield this.generateDid(checksum);
            this.id = didFromChecksum;
            this.authentication[0].publicKey = didFromChecksum;
            this.publicKey[0].id = didFromChecksum;
        });
    }
    generateDid(seed) {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.didPrefixed(utils_1.zeroX(this.checksum(JSON.stringify(seed))));
        });
    }
    addSignature(nevermined, publicKey, password) {
        return __awaiter(this, void 0, void 0, function* () {
            this.proof.signatureValue = yield nevermined.utils.signature.signText(this.shortId(), publicKey, password);
        });
    }
}
exports.DDO = DDO;
//# sourceMappingURL=DDO.js.map