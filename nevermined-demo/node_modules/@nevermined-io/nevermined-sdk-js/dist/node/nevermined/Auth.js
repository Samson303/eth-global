"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = void 0;
const Instantiable_abstract_1 = require("../Instantiable.abstract");
const defaultAuthMessage = 'Nevermined Protocol Authentication';
const defaultExpirationTime = 30 * 24 * 60 * 60 * 1000;
const localStorageKey = 'NeverminedTokens';
class Auth extends Instantiable_abstract_1.Instantiable {
    static getInstance(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new Auth();
            instance.setInstanceConfig(config);
            return instance;
        });
    }
    get(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const time = Math.floor(Date.now() / 1000);
            const message = `${this.getMessage()}\n${time}`;
            try {
                const signature = yield this.nevermined.utils.signature.signText(message, account.getId(), account.getPassword());
                return `${signature}-${time}`;
            }
            catch (_a) {
                throw new Error('User denied the signature.');
            }
        });
    }
    check(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const expiration = this.getExpiration();
            const [signature, timestamp] = token.split('-');
            const message = `${this.getMessage()}\n${timestamp}`;
            if (+timestamp * 1000 + expiration < Date.now()) {
                return `0x${'0'.repeat(40)}`;
            }
            return this.web3.utils.toChecksumAddress(yield this.nevermined.utils.signature.verifyText(message, signature));
        });
    }
    store(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.get(account);
            this.writeToken(account.getId(), token);
        });
    }
    restore(account) {
        return __awaiter(this, void 0, void 0, function* () {
            let token;
            try {
                token = this.readToken(account.getId());
            }
            catch (_a) {
                return;
            }
            if (!token) {
                return;
            }
            const signer = yield this.check(token);
            if (signer.toLowerCase() !== account.getId().toLowerCase()) {
                return;
            }
            return token;
        });
    }
    isStored(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.restore(account));
        });
    }
    writeToken(address, token) {
        const localStorage = this.getLocalStorage();
        const storedTokens = localStorage.getItem(localStorageKey);
        const tokens = storedTokens ? JSON.parse(storedTokens) : {};
        localStorage.setItem(localStorageKey, JSON.stringify(Object.assign(Object.assign({}, tokens), { [address]: token })));
    }
    readToken(address) {
        const localStorage = this.getLocalStorage();
        const storedTokens = localStorage.getItem(localStorageKey);
        const tokens = storedTokens ? JSON.parse(storedTokens) : {};
        return tokens[address];
    }
    getLocalStorage() {
        try {
            localStorage.getItem('');
        }
        catch (_a) {
            throw new Error('LocalStorage is not supported. This feature is only available on browsers.');
        }
        return localStorage;
    }
    getMessage() {
        return this.config.authMessage || defaultAuthMessage;
    }
    getExpiration() {
        return this.config.authTokenExpiration || defaultExpirationTime;
    }
}
exports.Auth = Auth;
//# sourceMappingURL=Auth.js.map