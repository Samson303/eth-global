"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Agreements = void 0;
const GeneratorHelpers_1 = require("../utils/GeneratorHelpers");
const DID_1 = __importDefault(require("./DID"));
const utils_1 = require("../utils");
const Instantiable_abstract_1 = require("../Instantiable.abstract");
const AgreementsConditions_1 = require("./AgreementsConditions");
class Agreements extends Instantiable_abstract_1.Instantiable {
    static getInstance(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new Agreements();
            instance.setInstanceConfig(config);
            instance.conditions = yield AgreementsConditions_1.AgreementsConditions.getInstance(config);
            return instance;
        });
    }
    prepare(did, index, consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            const d = DID_1.default.parse(did);
            const ddo = yield this.nevermined.metadata.retrieveDDO(d);
            const agreementId = utils_1.zeroX(GeneratorHelpers_1.generateId());
            const templateName = ddo.findServiceByType('access').attributes
                .serviceAgreementTemplate.contractName;
            const assetRewards = utils_1.getAssetRewardsFromDDO(ddo, index);
            const agreementConditionsIds = yield this.nevermined.keeper
                .getTemplateByName(templateName)
                .getAgreementIdsFromDDO(agreementId, ddo, assetRewards, consumer.getId(), consumer.getId());
            const signature = yield this.nevermined.utils.agreements.signServiceAgreement(ddo, index, agreementId, agreementConditionsIds, consumer);
            return { agreementId, signature };
        });
    }
    create(did, agreementId, index, consumer, publisher) {
        return __awaiter(this, void 0, void 0, function* () {
            const d = DID_1.default.parse(did);
            const ddo = yield this.nevermined.metadata.retrieveDDO(d);
            const templateName = ddo.findServiceById(index).attributes
                .serviceAgreementTemplate.contractName;
            const assetRewards = utils_1.getAssetRewardsFromDDO(ddo, index);
            yield this.nevermined.keeper
                .getTemplateByName(templateName)
                .createAgreementFromDDO(agreementId, ddo, assetRewards, consumer.getId(), publisher.getId());
            return true;
        });
    }
    status(agreementId, extended = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const { templateId } = yield this.nevermined.keeper.agreementStoreManager.getAgreement(agreementId);
            const fullStatus = yield this.nevermined.keeper
                .getTemplateByAddress(templateId)
                .getAgreementStatus(agreementId);
            if (!fullStatus) {
                return;
            }
            if (extended) {
                return fullStatus;
            }
            const simpleStatus = {};
            Object.entries(fullStatus).forEach(([condition, { state }]) => {
                simpleStatus[condition] = state;
            });
            return simpleStatus;
        });
    }
    isAccessGranted(agreementId, did, consumer, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const consumerAddress = this.nevermined.keeper.templates.escrowAccessSecretStoreTemplate.getAgreementData(agreementId)[0];
            if (!consumer.includes(consumerAddress)) {
                console.log(`This address [${consumer}] has not access granted`);
                return false;
            }
            return yield this.nevermined.keeper.conditions.accessSecretStoreCondition.checkPermissions(consumerAddress, did, account.getId());
        });
    }
}
exports.Agreements = Agreements;
//# sourceMappingURL=Agreements.js.map