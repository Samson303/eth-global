import { TransactionReceipt } from 'web3-core';
import { SearchQuery } from '../metadata/Metadata';
import { DDO } from '../ddo/DDO';
import { MetaData } from '../ddo/MetaData';
import { Service, ServiceType } from '../ddo/Service';
import Account from './Account';
import { SubscribablePromise } from '../utils';
import { Instantiable, InstantiableConfig } from '../Instantiable.abstract';
import AssetRewards from '../models/AssetRewards';
export declare enum CreateProgressStep {
    GeneratingProof = 0,
    ProofGenerated = 1,
    EncryptingFiles = 2,
    FilesEncrypted = 3,
    RegisteringDid = 4,
    DidRegistered = 5,
    StoringDdo = 6,
    DdoStored = 7
}
export declare enum OrderProgressStep {
    CreatingAgreement = 0,
    AgreementInitialized = 1,
    LockingPayment = 2,
    LockedPayment = 3
}
export declare enum ExecuteProgressStep {
    CreatingAgreement = 0,
    AgreementInitialized = 1,
    LockingPayment = 2,
    LockedPayment = 3
}
export declare class Assets extends Instantiable {
    static getInstance(config: InstantiableConfig): Promise<Assets>;
    resolve(did: string): Promise<DDO>;
    create(metadata: MetaData, publisher: Account, assetRewards?: AssetRewards, serviceTypes?: ServiceType[], services?: Service[], method?: string, providers?: string[]): SubscribablePromise<CreateProgressStep, DDO>;
    createCompute(metadata: MetaData, publisher: Account, assetRewards?: AssetRewards, service?: Service[], method?: string): SubscribablePromise<CreateProgressStep, DDO>;
    consume(agreementId: string, did: string, serviceIndex: number, consumerAccount: Account, resultPath: string, index?: number, useSecretStore?: boolean): Promise<string>;
    consume(agreementId: string, did: string, serviceIndex: number, consumerAccount: Account, resultPath?: undefined | null, index?: number, useSecretStore?: boolean): Promise<true>;
    order(did: string, index: number, consumer: Account): SubscribablePromise<OrderProgressStep, string>;
    execute(agreementId: string, computeDid: string, workflowDid: string, consumer: Account): Promise<string>;
    owner(did: string): Promise<string>;
    ownerAssets(owner: string): Promise<string[]>;
    transferOwnership(did: string, newOwner: string): Promise<TransactionReceipt>;
    consumerAssets(consumer: string): Promise<string[]>;
    query(query: SearchQuery): Promise<import("../metadata/Metadata").QueryResult>;
    search(text: string, offset?: number, page?: number, sort?: number): Promise<import("../metadata/Metadata").QueryResult>;
    retire(did: string): Promise<import("node-fetch").Response>;
    download(did: string, serviceIndex: number, ownerAccount: Account, resultPath: string, index?: number, useSecretStore?: boolean): Promise<string>;
    download(did: string, serviceIndex: number, ownerAccount: Account, resultPath?: undefined | null, index?: number, useSecretStore?: boolean): Promise<true>;
    delegatePermissions(did: string, address: string, account: Account): Promise<TransactionReceipt>;
    revokePermissions(did: string, address: string, account: Account): Promise<TransactionReceipt>;
    getPermissions(did: string, address: string): Promise<boolean>;
    computeLogs(agreementId: string, executionId: string, account: Account): Promise<any>;
    computeStatus(agreementId: string, executionId: string, account: Account): Promise<any>;
    mint(did: string, amount: number, account: Account): Promise<TransactionReceipt>;
    burn(did: string, amount: number, account: Account): Promise<TransactionReceipt>;
    transferNft(did: string, to: string, amount: number, account: Account): Promise<TransactionReceipt>;
    balance(address: string, did: string): Promise<number>;
    private providerConfig;
    private createAccessService;
    private createComputeService;
    private createAuthorizationService;
}
