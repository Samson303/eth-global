"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServiceAgreement = void 0;
const utils_1 = require("../../utils");
const Instantiable_abstract_1 = require("../../Instantiable.abstract");
class ServiceAgreement extends Instantiable_abstract_1.Instantiable {
    constructor(config) {
        super();
        this.setInstanceConfig(config);
    }
    signServiceAgreement(ddo, index, serviceAgreementId, agreementConditionsIds, consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            const service = ddo.findServiceById(index);
            const timelockValues = this.getTimeValuesFromService(service, 'timelock');
            const timeoutValues = this.getTimeValuesFromService(service, 'timeout');
            if (!service.templateId) {
                throw new Error('TemplateId not found in DDO.');
            }
            const serviceAgreementHashSignature = yield this.createHashSignature(service.templateId, serviceAgreementId, agreementConditionsIds, timelockValues, timeoutValues, consumer);
            this.logger.debug('SA hash signature:', serviceAgreementHashSignature);
            return utils_1.zeroX(serviceAgreementHashSignature);
        });
    }
    createHashSignature(templateId, serviceAgreementId, valueHashes, timelockValues, timeoutValues, consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            const serviceAgreementHash = this.hashServiceAgreement(templateId, serviceAgreementId, valueHashes, timelockValues, timeoutValues);
            const serviceAgreementHashSignature = yield this.nevermined.utils.signature.signText(serviceAgreementHash, consumer.getId(), consumer.getPassword());
            return serviceAgreementHashSignature;
        });
    }
    hashServiceAgreement(serviceAgreementTemplateId, serviceAgreementId, valueHashes, timelocks, timeouts) {
        const args = [
            { type: 'address', value: utils_1.zeroX(serviceAgreementTemplateId) },
            { type: 'bytes32[]', value: valueHashes.map(utils_1.zeroX) },
            { type: 'uint256[]', value: timelocks },
            { type: 'uint256[]', value: timeouts },
            { type: 'bytes32', value: utils_1.zeroX(serviceAgreementId) }
        ];
        return this.web3.utils.soliditySha3(...args);
    }
    getTimeValuesFromService(service, type) {
        const timeoutValues = service.attributes.serviceAgreementTemplate.conditions.map((condition) => condition[type]);
        return timeoutValues;
    }
}
exports.ServiceAgreement = ServiceAgreement;
//# sourceMappingURL=ServiceAgreement.js.map