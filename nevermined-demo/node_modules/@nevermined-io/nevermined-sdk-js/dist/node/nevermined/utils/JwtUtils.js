"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JwtUtils = void 0;
const parse_1 = __importDefault(require("jose/jwk/parse"));
const sign_1 = __importDefault(require("jose/jwt/sign"));
const Instantiable_abstract_1 = require("../../Instantiable.abstract");
class EthSignJWT extends sign_1.default {
    setProtectedHeader(protectedHeader) {
        this.protectedHeader = protectedHeader;
        return this;
    }
    ethSign(account, signatureUtils, web3) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoder = new TextEncoder();
            const decoder = new TextDecoder();
            const encodedPayload = encoder.encode(this.base64url(JSON.stringify(this._payload)));
            const encodedHeader = encoder.encode(this.base64url(JSON.stringify(this.protectedHeader)));
            const data = this.concat(encodedHeader, encoder.encode('.'), encodedPayload);
            const sign = yield signatureUtils.signText(decoder.decode(data), account.getId());
            const signed = this.base64url(Uint8Array.from(web3.utils.hexToBytes(sign).slice(0, 64)));
            const grantToken = `${decoder.decode(encodedHeader)}.${decoder.decode(encodedPayload)}.${signed}`;
            return grantToken;
        });
    }
    base64url(input) {
        return Buffer.from(input).toString('base64').replace(/=/g, '').replace(/\+/g, '-').replace(/\//g, '_');
    }
    concat(...buffers) {
        const size = buffers.reduce((acc, { length }) => acc + length, 0);
        const buf = new Uint8Array(size);
        let i = 0;
        buffers.forEach((buffer) => {
            buf.set(buffer, i);
            i += buffer.length;
        });
        return buf;
    }
}
class JwtUtils extends Instantiable_abstract_1.Instantiable {
    constructor(config) {
        super();
        this.GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:jwt-bearer';
        this.BASE_AUD = '/api/v1/gateway/services';
        this.setInstanceConfig(config);
        this.tokenCache = new Map();
    }
    generateCacheKey(...args) {
        return args.join();
    }
    accountToJwk(account) {
        return __awaiter(this, void 0, void 0, function* () {
            const address = account.getId().toLowerCase();
            const publicKey = this.web3.currentProvider.wallets[address].getPublicKey();
            const privateKey = this.web3.currentProvider.wallets[address].getPrivateKey();
            return parse_1.default({
                alg: 'ES256K',
                crv: 'secp256k1',
                kty: 'EC',
                d: privateKey.toString('base64'),
                x: publicKey.slice(0, 32).toString('base64'),
                y: publicKey.slice(32, 64).toString('base64')
            });
        });
    }
    generateAccessGrantToken(account, serviceAgreementId, did) {
        return __awaiter(this, void 0, void 0, function* () {
            return new EthSignJWT({
                iss: account.getId(),
                aud: this.BASE_AUD + '/access',
                sub: serviceAgreementId,
                did: did,
                eths: 'personal'
            })
                .setProtectedHeader({ alg: 'ES256K' })
                .setIssuedAt()
                .setExpirationTime('1h')
                .ethSign(account, this.nevermined.utils.signature, this.web3);
        });
    }
    generateDownloadGrantToken(account, did) {
        return __awaiter(this, void 0, void 0, function* () {
            return new EthSignJWT({
                iss: account.getId(),
                aud: this.BASE_AUD + '/download',
                did: did,
                eths: 'personal'
            })
                .setProtectedHeader({ alg: 'ES256K' })
                .setIssuedAt()
                .setExpirationTime('1h')
                .ethSign(account, this.nevermined.utils.signature, this.web3);
        });
    }
    generateExecuteGrantToken(account, serviceAgreementId, workflowId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new EthSignJWT({
                iss: account.getId(),
                aud: this.BASE_AUD + '/execute',
                sub: serviceAgreementId,
                did: workflowId,
                eths: 'personal'
            })
                .setProtectedHeader({ alg: 'ES256K' })
                .setIssuedAt()
                .setExpirationTime('1h')
                .ethSign(account, this.nevermined.utils.signature, this.web3);
        });
    }
    generateComputeGrantToken(account, serviceAgreementId, executionId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new EthSignJWT({
                iss: account.getId(),
                aud: this.BASE_AUD + '/compute',
                sub: serviceAgreementId,
                eths: 'personal',
                'execution_id': executionId
            })
                .setProtectedHeader({ alg: 'ES256K' })
                .setIssuedAt()
                .setExpirationTime('1h')
                .ethSign(account, this.nevermined.utils.signature, this.web3);
        });
    }
}
exports.JwtUtils = JwtUtils;
//# sourceMappingURL=JwtUtils.js.map