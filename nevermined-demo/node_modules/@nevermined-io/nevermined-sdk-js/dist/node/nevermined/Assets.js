"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Assets = exports.ExecuteProgressStep = exports.OrderProgressStep = exports.CreateProgressStep = void 0;
const DDO_1 = require("../ddo/DDO");
const DID_1 = __importDefault(require("./DID"));
const utils_1 = require("../utils");
const Instantiable_abstract_1 = require("../Instantiable.abstract");
const AssetRewards_1 = __importDefault(require("../models/AssetRewards"));
var CreateProgressStep;
(function (CreateProgressStep) {
    CreateProgressStep[CreateProgressStep["GeneratingProof"] = 0] = "GeneratingProof";
    CreateProgressStep[CreateProgressStep["ProofGenerated"] = 1] = "ProofGenerated";
    CreateProgressStep[CreateProgressStep["EncryptingFiles"] = 2] = "EncryptingFiles";
    CreateProgressStep[CreateProgressStep["FilesEncrypted"] = 3] = "FilesEncrypted";
    CreateProgressStep[CreateProgressStep["RegisteringDid"] = 4] = "RegisteringDid";
    CreateProgressStep[CreateProgressStep["DidRegistered"] = 5] = "DidRegistered";
    CreateProgressStep[CreateProgressStep["StoringDdo"] = 6] = "StoringDdo";
    CreateProgressStep[CreateProgressStep["DdoStored"] = 7] = "DdoStored";
})(CreateProgressStep = exports.CreateProgressStep || (exports.CreateProgressStep = {}));
var OrderProgressStep;
(function (OrderProgressStep) {
    OrderProgressStep[OrderProgressStep["CreatingAgreement"] = 0] = "CreatingAgreement";
    OrderProgressStep[OrderProgressStep["AgreementInitialized"] = 1] = "AgreementInitialized";
    OrderProgressStep[OrderProgressStep["LockingPayment"] = 2] = "LockingPayment";
    OrderProgressStep[OrderProgressStep["LockedPayment"] = 3] = "LockedPayment";
})(OrderProgressStep = exports.OrderProgressStep || (exports.OrderProgressStep = {}));
var ExecuteProgressStep;
(function (ExecuteProgressStep) {
    ExecuteProgressStep[ExecuteProgressStep["CreatingAgreement"] = 0] = "CreatingAgreement";
    ExecuteProgressStep[ExecuteProgressStep["AgreementInitialized"] = 1] = "AgreementInitialized";
    ExecuteProgressStep[ExecuteProgressStep["LockingPayment"] = 2] = "LockingPayment";
    ExecuteProgressStep[ExecuteProgressStep["LockedPayment"] = 3] = "LockedPayment";
})(ExecuteProgressStep = exports.ExecuteProgressStep || (exports.ExecuteProgressStep = {}));
class Assets extends Instantiable_abstract_1.Instantiable {
    static getInstance(config) {
        return __awaiter(this, void 0, void 0, function* () {
            const instance = new Assets();
            instance.setInstanceConfig(config);
            return instance;
        });
    }
    resolve(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const { serviceEndpoint } = yield this.nevermined.keeper.didRegistry.getAttributesByDid(did);
            return this.nevermined.metadata.retrieveDDOByUrl(serviceEndpoint);
        });
    }
    create(metadata, publisher, assetRewards = new AssetRewards_1.default(), serviceTypes = ['access'], services = [], method = 'PSK-RSA', providers) {
        this.logger.log('Creating asset');
        return new utils_1.SubscribablePromise((observer) => __awaiter(this, void 0, void 0, function* () {
            var _a;
            const { gatewayUri } = this.config;
            const { didRegistry, templates } = this.nevermined.keeper;
            const accessServiceAgreementTemplate = yield templates.escrowAccessSecretStoreTemplate.getServiceAgreementTemplate();
            const computeServiceAgreementTemplate = yield templates.escrowComputeExecutionTemplate.getServiceAgreementTemplate();
            const ddo = new DDO_1.DDO({
                id: '',
                authentication: [
                    {
                        type: 'RsaSignatureAuthentication2018',
                        publicKey: ''
                    }
                ],
                publicKey: [
                    {
                        id: '',
                        type: 'EthereumECDSAKey',
                        owner: publisher.getId()
                    }
                ],
            });
            if (services.length > 0) {
                ddo.service = [, ...services].reverse();
            }
            if (serviceTypes.includes('access'))
                ddo.addService(this.nevermined, this.createAccessService(templates, publisher, metadata, accessServiceAgreementTemplate));
            if (serviceTypes.includes('compute'))
                yield ddo.addService(this.nevermined, this.createComputeService(templates, publisher, metadata, computeServiceAgreementTemplate));
            let publicKey = yield this.nevermined.gateway.getRsaPublicKey();
            if (method == 'PSK_ECDSA') {
                publicKey = this.nevermined.gateway.getEcdsaPublicKey();
            }
            yield ddo.addService(this.nevermined, this.createAuthorizationService(gatewayUri, publicKey, method));
            yield ddo.addService(this.nevermined, {
                type: 'metadata',
                index: 0,
                serviceEndpoint: '',
                attributes: Object.assign(Object.assign({ curation: {
                        rating: 0,
                        numVotes: 0
                    } }, metadata), { main: Object.assign({}, metadata.main) })
            });
            ddo.service.sort((a, b) => (a.index > b.index) ? 1 : -1);
            this.logger.log('Generating proof');
            observer.next(CreateProgressStep.GeneratingProof);
            yield ddo.addProof(this.nevermined, publisher.getId(), publisher.getPassword());
            yield ddo.assignDid(ddo.proof.checksum);
            yield ddo.addSignature(this.nevermined, publisher.getId(), publisher.getPassword());
            this.logger.log('Proof generated');
            observer.next(CreateProgressStep.ProofGenerated);
            this.logger.log('Encrypting files');
            observer.next(CreateProgressStep.EncryptingFiles);
            let encryptedFiles;
            if (!['workflow'].includes(metadata.main.type)) {
                if (method === 'SecretStore') {
                    encryptedFiles = yield this.nevermined.secretStore.encrypt(ddo.id, metadata.main.files, publisher);
                }
                else {
                    const encryptedFilesResponse = yield this.nevermined.gateway.encrypt(ddo.id, JSON.stringify(metadata.main.files), method);
                    encryptedFiles = JSON.parse(encryptedFilesResponse)['hash'];
                }
            }
            const serviceEndpoint = this.nevermined.metadata.getServiceEndpoint(DID_1.default.parse(ddo.id));
            yield ddo.updateService(this.nevermined, {
                type: 'metadata',
                index: 0,
                serviceEndpoint,
                attributes: Object.assign(Object.assign({ curation: {
                        rating: 0,
                        numVotes: 0
                    } }, metadata), { encryptedFiles, main: Object.assign(Object.assign({}, metadata.main), { files: (_a = metadata.main.files) === null || _a === void 0 ? void 0 : _a.map((file, index) => (Object.assign(Object.assign({}, file), { index, url: undefined }))) }) })
            });
            if (serviceTypes.includes('access')) {
                const rawConditions = yield templates.escrowAccessSecretStoreTemplate.getServiceAgreementTemplateConditions();
                const conditions = utils_1.fillConditionsWithDDO(rawConditions, ddo, assetRewards);
                accessServiceAgreementTemplate.conditions = conditions;
            }
            if (serviceTypes.includes('compute')) {
                const rawConditions = yield templates.escrowComputeExecutionTemplate.getServiceAgreementTemplateConditions();
                const conditions = utils_1.fillConditionsWithDDO(rawConditions, ddo, assetRewards);
                computeServiceAgreementTemplate.conditions = conditions;
            }
            this.logger.log('Files encrypted');
            observer.next(CreateProgressStep.FilesEncrypted);
            this.logger.log('Registering DID');
            observer.next(CreateProgressStep.RegisteringDid);
            yield didRegistry.registerAttribute(ddo.shortId(), ddo.checksum(ddo.shortId()), providers || [this.config.gatewayAddress], serviceEndpoint, publisher.getId());
            this.logger.log('DID registred');
            observer.next(CreateProgressStep.DidRegistered);
            this.logger.log('Storing DDO');
            observer.next(CreateProgressStep.StoringDdo);
            const storedDdo = yield this.nevermined.metadata.storeDDO(ddo);
            this.logger.log('DDO stored');
            observer.next(CreateProgressStep.DdoStored);
            return storedDdo;
        }));
    }
    createCompute(metadata, publisher, assetRewards = new AssetRewards_1.default(), service = [], method = 'PSK-RSA') {
        return new utils_1.SubscribablePromise((observer) => __awaiter(this, void 0, void 0, function* () {
            const computeService = { main: {
                    name: "dataAssetComputeServiceAgreement",
                    creator: publisher.getId(),
                    datePublished: metadata.main.dateCreated,
                    price: metadata.main.price,
                    timeout: 86400,
                    provider: this.providerConfig()
                }
            };
            return this.create(metadata, publisher, assetRewards, ['compute'], [{
                    type: 'compute',
                    index: 4,
                    serviceEndpoint: this.nevermined.gateway.getExecutionEndpoint(),
                    attributes: computeService
                }], method);
        }));
    }
    consume(agreementId, did, serviceIndex, consumerAccount, resultPath, index = -1, useSecretStore) {
        return __awaiter(this, void 0, void 0, function* () {
            const ddo = yield this.resolve(did);
            const { attributes } = ddo.findServiceByType('metadata');
            const accessService = ddo.findServiceById(serviceIndex);
            const { files } = attributes.main;
            const { serviceEndpoint } = accessService;
            if (!serviceEndpoint) {
                throw new Error('Consume asset failed, service definition is missing the `serviceEndpoint`.');
            }
            this.logger.log('Consuming files');
            resultPath = resultPath
                ? `${resultPath}/datafile.${ddo.shortId()}.${serviceIndex}/`
                : undefined;
            if (!useSecretStore) {
                yield this.nevermined.gateway.consumeService(did, agreementId, serviceEndpoint, consumerAccount, files, resultPath, index);
            }
            else {
                const files = yield this.nevermined.secretStore.decrypt(did, ddo.findServiceByType('metadata').attributes.encryptedFiles, consumerAccount, ddo.findServiceByType('authorization').serviceEndpoint);
                const downloads = files
                    .filter(({ index: i }) => index === -1 || index === i)
                    .map(({ url, index: i }) => this.nevermined.utils.fetch.downloadFile(url, resultPath, i));
                yield Promise.all(downloads);
            }
            this.logger.log('Files consumed');
            if (resultPath) {
                return resultPath;
            }
            return true;
        });
    }
    order(did, index, consumer) {
        return new utils_1.SubscribablePromise((observer) => __awaiter(this, void 0, void 0, function* () {
            const { agreements } = this.nevermined;
            const agreementId = utils_1.zeroX(utils_1.generateId());
            const ddo = yield this.resolve(did);
            const { keeper } = this.nevermined;
            const service = ddo.findServiceById(index);
            const templateName = service.attributes.serviceAgreementTemplate.contractName;
            const template = keeper.getTemplateByName(templateName);
            const totalAmount = utils_1.getLockRewardTotalAmount(ddo, index);
            const paymentFlow = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                yield template.getAgreementCreatedEvent(agreementId).once();
                this.logger.log('Agreement initialized');
                observer.next(OrderProgressStep.AgreementInitialized);
                const { attributes } = ddo.findServiceByType('metadata');
                this.logger.log('Locking payment');
                observer.next(OrderProgressStep.LockingPayment);
                const paid = yield agreements.conditions.lockReward(agreementId, totalAmount, consumer);
                observer.next(OrderProgressStep.LockedPayment);
                if (paid) {
                    this.logger.log('Payment was OK');
                }
                else {
                    this.logger.error('Payment was KO');
                    this.logger.error('Agreement ID: ', agreementId);
                    this.logger.error('DID: ', ddo.id);
                    reject(new Error('Error on payment'));
                }
                resolve(did);
            }));
            observer.next(OrderProgressStep.CreatingAgreement);
            this.logger.log('Creating agreement');
            yield agreements.create(did, agreementId, index, consumer, consumer);
            this.logger.log('Agreement created');
            try {
                yield paymentFlow;
            }
            catch (e) {
                throw new Error('Error paying the asset.');
            }
            return agreementId;
        }));
    }
    execute(agreementId, computeDid, workflowDid, consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            const { gateway } = this.nevermined;
            return (yield gateway.execute(agreementId, computeDid, workflowDid, consumer)).workflowId;
        });
    }
    owner(did) {
        return __awaiter(this, void 0, void 0, function* () {
            const ddo = yield this.resolve(did);
            const checksum = ddo.checksum(utils_1.didZeroX(did));
            const { creator, signatureValue } = ddo.proof;
            const signer = yield this.nevermined.utils.signature.verifyText(checksum, signatureValue);
            if (signer.toLowerCase() !== creator.toLowerCase()) {
                this.logger.warn(`Owner of ${ddo.id} doesn't match. Expected ${creator} instead of ${signer}.`);
            }
            return creator;
        });
    }
    ownerAssets(owner) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nevermined.keeper.didRegistry.getAttributesByOwner(owner);
        });
    }
    transferOwnership(did, newOwner) {
        return __awaiter(this, void 0, void 0, function* () {
            const owner = yield this.nevermined.assets.owner(did);
            return this.nevermined.keeper.didRegistry.transferDIDOwnership(did, newOwner, owner);
        });
    }
    consumerAssets(consumer) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.nevermined.keeper.conditions.accessSecretStoreCondition.getGrantedDidByConsumer(consumer)).map(({ did }) => did);
        });
    }
    query(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nevermined.metadata.queryMetadata(query);
        });
    }
    search(text, offset = 100, page = 1, sort = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nevermined.metadata.queryMetadataByText({
                text,
                page: page,
                offset: offset,
                query: {
                    value: 1
                },
                sort: {
                    value: sort
                }
            });
        });
    }
    retire(did) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nevermined.metadata.delete(did);
        });
    }
    download(did, serviceIndex, ownerAccount, resultPath, index = -1, useSecretStore) {
        return __awaiter(this, void 0, void 0, function* () {
            const ddo = yield this.resolve(did);
            const { attributes } = ddo.findServiceByType('metadata');
            const accessService = ddo.findServiceById(serviceIndex);
            const { files } = attributes.main;
            const { serviceEndpoint } = accessService;
            if (!serviceEndpoint) {
                throw new Error('Consume asset failed, service definition is missing the `serviceEndpoint`.');
            }
            this.logger.log('Consuming files');
            resultPath = resultPath
                ? `${resultPath}/datafile.${ddo.shortId()}.${serviceIndex}/`
                : undefined;
            if (!useSecretStore) {
                yield this.nevermined.gateway.downloadService(did, ownerAccount, files, resultPath, index);
            }
            else {
                const files = yield this.nevermined.secretStore.decrypt(did, ddo.findServiceByType('metadata').attributes.encryptedFiles, ownerAccount, ddo.findServiceByType('authorization').serviceEndpoint);
                const downloads = files
                    .filter(({ index: i }) => index === -1 || index === i)
                    .map(({ url, index: i }) => this.nevermined.utils.fetch.downloadFile(url, resultPath, i));
                yield Promise.all(downloads);
            }
            this.logger.log('Files consumed');
            if (resultPath) {
                return resultPath;
            }
            return true;
        });
    }
    delegatePermissions(did, address, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.grantPermission(did, address, account.getId());
        });
    }
    revokePermissions(did, address, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.revokePermission(did, address, account.getId());
        });
    }
    getPermissions(did, address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.getPermission(did, address);
        });
    }
    computeLogs(agreementId, executionId, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.gateway.computeLogs(agreementId, executionId, account);
        });
    }
    computeStatus(agreementId, executionId, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.gateway.computeStatus(agreementId, executionId, account);
        });
    }
    mint(did, amount, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.mint(did, amount, account.getId());
        });
    }
    burn(did, amount, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.burn(did, amount, account.getId());
        });
    }
    transferNft(did, to, amount, account) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.transferNft(did, to, amount, account.getId());
        });
    }
    balance(address, did) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.nevermined.keeper.didRegistry.balance(address, did);
        });
    }
    providerConfig() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                'type': 'Azure',
                'description': '',
                'environment': {
                    'cluster': {
                        'type': 'Kubernetes',
                        'url': 'http://10.0.0.17/xxx'
                    },
                    'supportedContainers': [
                        {
                            'image': 'tensorflow/tensorflow',
                            'tag': 'latest',
                            'checksum': 'sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc'
                        },
                        {
                            'image': 'tensorflow/tensorflow',
                            'tag': 'latest',
                            'checksum': 'sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc'
                        }
                    ],
                    'supportedServers': [
                        {
                            'serverId': '1',
                            'serverType': 'xlsize',
                            'price': '50',
                            'cpu': '16',
                            'gpu': '0',
                            'memory': '128gb',
                            'disk': '160gb',
                            'maxExecutionTime': 86400
                        },
                        {
                            'serverId': '2',
                            'serverType': 'medium',
                            'price': '10',
                            'cpu': '2',
                            'gpu': '0',
                            'memory': '8gb',
                            'disk': '80gb',
                            'maxExecutionTime': 86400
                        }
                    ]
                }
            };
        });
    }
    createAccessService(templates, publisher, metadata, serviceAgreementTemplate) {
        return {
            type: 'access',
            index: 3,
            serviceEndpoint: this.nevermined.gateway.getAccessEndpoint(),
            templateId: templates.escrowAccessSecretStoreTemplate.getAddress(),
            attributes: {
                main: {
                    creator: publisher.getId(),
                    datePublished: metadata.main.datePublished,
                    name: 'dataAssetAccessServiceAgreement',
                    price: metadata.main.price,
                    timeout: 3600
                },
                serviceAgreementTemplate
            }
        };
    }
    createComputeService(templates, publisher, metadata, serviceAgreementTemplate) {
        return {
            type: 'compute',
            index: 4,
            serviceEndpoint: this.nevermined.gateway.getExecutionEndpoint(),
            templateId: templates.escrowComputeExecutionTemplate.getAddress(),
            attributes: {
                main: {
                    name: 'dataAssetComputeServiceAgreement',
                    creator: publisher.getId(),
                    datePublished: metadata.main.datePublished,
                    price: metadata.main.price,
                    timeout: 86400,
                    provider: this.providerConfig()
                },
                serviceAgreementTemplate
            }
        };
    }
    createAuthorizationService(gatewayUri, publicKey, method) {
        return {
            type: 'authorization',
            index: 2,
            serviceEndpoint: gatewayUri,
            attributes: {
                main: {
                    publicKey: publicKey,
                    service: method,
                    threshold: 0
                }
            }
        };
    }
}
exports.Assets = Assets;
//# sourceMappingURL=Assets.js.map