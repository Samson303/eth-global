"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Metadata = void 0;
const whatwg_url_1 = require("whatwg-url");
const DDO_1 = require("../ddo/DDO");
const DID_1 = __importDefault(require("../nevermined/DID"));
const Instantiable_abstract_1 = require("../Instantiable.abstract");
const apiPath = '/api/v1/metadata/assets/ddo';
class Metadata extends Instantiable_abstract_1.Instantiable {
    get url() {
        return this.config.metadataUri;
    }
    constructor(config) {
        super();
        this.setInstanceConfig(config);
    }
    getVersionInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.nevermined.utils.fetch.get(this.url)).json();
        });
    }
    getAccessUrl(accessToken, payload) {
        return __awaiter(this, void 0, void 0, function* () {
            const accessUrl = yield this.nevermined.utils.fetch
                .post(`${accessToken.service_endpoint}/${accessToken.resource_id}`, payload)
                .then((response) => {
                if (response.ok) {
                    return response.text();
                }
                this.logger.error('Failed: ', response.status, response.statusText);
                return null;
            })
                .then((consumptionUrl) => {
                this.logger.error('Success accessing consume endpoint: ', consumptionUrl);
                return consumptionUrl;
            })
                .catch(error => {
                this.logger.error('Error fetching the data asset consumption url: ', error);
                return null;
            });
            return accessUrl;
        });
    }
    queryMetadata(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.nevermined.utils.fetch
                .post(`${this.url}${apiPath}/query`, JSON.stringify(query))
                .then((response) => {
                if (response.ok) {
                    return response.json();
                }
                this.logger.error('queryMetadata failed:', response.status, response.statusText);
                return this.transformResult();
            })
                .then(results => {
                return this.transformResult(results);
            })
                .catch(error => {
                this.logger.error('Error fetching querying metadata: ', error);
                return this.transformResult();
            });
            return result;
        });
    }
    queryMetadataByText(query) {
        return __awaiter(this, void 0, void 0, function* () {
            const fullUrl = new whatwg_url_1.URL(`${this.url}${apiPath}/query`);
            fullUrl.searchParams.append('text', query.text);
            fullUrl.searchParams.append('sort', decodeURIComponent(JSON.stringify(query.sort)));
            fullUrl.searchParams.append('offset', query.offset.toString());
            fullUrl.searchParams.append('page', query.page.toString());
            const result = yield this.nevermined.utils.fetch
                .get(fullUrl)
                .then((response) => {
                if (response.ok) {
                    return response.json();
                }
                this.logger.log('queryMetadataByText failed:', response.status, response.statusText);
                return this.transformResult();
            })
                .then(results => {
                return this.transformResult(results);
            })
                .catch(error => {
                this.logger.error('Error fetching querying metadata by text: ', error);
                return this.transformResult();
            });
            return result;
        });
    }
    storeDDO(ddo) {
        return __awaiter(this, void 0, void 0, function* () {
            const fullUrl = `${this.url}${apiPath}`;
            const result = yield this.nevermined.utils.fetch
                .post(fullUrl, DDO_1.DDO.serialize(ddo))
                .then((response) => {
                if (response.ok) {
                    return response.json();
                }
                this.logger.error('storeDDO failed:', response.status, response.statusText, ddo);
                return null;
            })
                .then((response) => {
                return new DDO_1.DDO(response);
            })
                .catch(error => {
                this.logger.error('Error fetching querying metadata: ', error);
                return null;
            });
            return result;
        });
    }
    retrieveDDO(did, metadataServiceEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            did = did && DID_1.default.parse(did);
            const fullUrl = metadataServiceEndpoint || `${this.url}${apiPath}/${did.getDid()}`;
            const result = yield this.nevermined.utils.fetch
                .get(fullUrl)
                .then((response) => {
                if (response.ok) {
                    return response.json();
                }
                this.logger.log('retrieveDDO failed:', response.status, response.statusText, did);
                return null;
            })
                .then((response) => {
                return new DDO_1.DDO(response);
            })
                .catch(error => {
                this.logger.error('Error fetching querying metadata: ', error);
                return null;
            });
            return result;
        });
    }
    delete(did) {
        return __awaiter(this, void 0, void 0, function* () {
            did = did && DID_1.default.parse(did);
            const result = yield this.nevermined.utils.fetch.delete(`${this.url}${apiPath}//${did.getDid()}`);
            return result;
        });
    }
    retrieveDDOByUrl(metadataServiceEndpoint) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.retrieveDDO(undefined, metadataServiceEndpoint);
        });
    }
    getServiceEndpoint(did) {
        return `${this.url}${apiPath}/did:nv:${did.getId()}`;
    }
    transformResult({ results, page, total_pages: totalPages, total_results: totalResults } = {
        result: [],
        page: 0,
        total_pages: 0,
        total_results: 0
    }) {
        return {
            results: (results || []).map(ddo => new DDO_1.DDO(ddo)),
            page,
            totalPages,
            totalResults
        };
    }
}
exports.Metadata = Metadata;
//# sourceMappingURL=Metadata.js.map