"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Gateway = void 0;
const utils_1 = require("../utils");
const Instantiable_abstract_1 = require("../Instantiable.abstract");
const apiPath = '/api/v1/gateway/services';
class Gateway extends Instantiable_abstract_1.Instantiable {
    get url() {
        return this.config.gatewayUri;
    }
    constructor(config) {
        super();
        this.setInstanceConfig(config);
    }
    getVersionInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.nevermined.utils.fetch.get(this.url)).json();
        });
    }
    getPurchaseEndpoint() {
        return `${this.url}${apiPath}/access/initialize`;
    }
    getConsumeEndpoint() {
        return `${this.url}${apiPath}/consume`;
    }
    getAccessEndpoint() {
        return `${this.url}${apiPath}/access`;
    }
    getComputeLogsEndpoint(serviceAgreementId, executionId) {
        return `${this.url}${apiPath}/compute/logs/${serviceAgreementId}/${executionId}`;
    }
    getComputeStatusEndpoint(serviceAgreementId, executionId) {
        return `${this.url}${apiPath}/compute/status/${serviceAgreementId}/${executionId}`;
    }
    getExecuteEndpoint(serviceAgreementId) {
        return `${this.url}${apiPath}/execute/${serviceAgreementId}`;
    }
    getExecutionEndpoint() {
        return `${this.url}${apiPath}/execute/`;
    }
    getSecretStoreEncryptEndpoint() {
        return `${this.url}${apiPath}/publish`;
    }
    getEncryptEndpoint() {
        return `${this.url}${apiPath}/encrypt`;
    }
    getFetchTokenEndpoint() {
        return `${this.url}${apiPath}/oauth/token`;
    }
    getGatewayInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.nevermined.utils.fetch.get(`${this.url}`)
                .then(res => res.json());
        });
    }
    getRsaPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getGatewayInfo();
            return json['rsa-public-key'];
        });
    }
    getEcdsaPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.getGatewayInfo();
            return json['ecdsa-public-key'];
        });
    }
    getDownloadEndpoint() {
        return `${this.url}${apiPath}/download`;
    }
    initializeServiceAgreement(did, serviceAgreementId, serviceIndex, signature, consumerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = {
                did,
                serviceAgreementId,
                serviceIndex,
                signature,
                consumerAddress
            };
            try {
                return yield this.nevermined.utils.fetch.post(this.getPurchaseEndpoint(), decodeURI(JSON.stringify(args)));
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    consumeService(did, agreementId, serviceEndpoint, account, files, destination, index = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const { jwt } = this.nevermined.utils;
            let accessToken;
            const cacheKey = jwt.generateCacheKey(account.getId(), agreementId, did);
            if (!jwt.tokenCache.has(cacheKey)) {
                const grantToken = yield jwt.generateAccessGrantToken(account, agreementId, did);
                accessToken = yield this.fetchToken(grantToken);
                jwt.tokenCache.set(cacheKey, accessToken);
            }
            else {
                accessToken = this.nevermined.utils.jwt.tokenCache.get(cacheKey);
            }
            const headers = {
                Authorization: "Bearer " + accessToken
            };
            const filesPromises = files
                .filter((_, i) => index === -1 || i === index)
                .map(({ index: i }) => __awaiter(this, void 0, void 0, function* () {
                const consumeUrl = `${serviceEndpoint}/${utils_1.noZeroX(agreementId)}/${i}`;
                try {
                    yield this.nevermined.utils.fetch.downloadFile(consumeUrl, destination, i, headers);
                }
                catch (e) {
                    this.logger.error('Error consuming assets');
                    this.logger.error(e);
                    throw e;
                }
            }));
            yield Promise.all(filesPromises);
            return destination;
        });
    }
    secretStoreEncrypt(did, signature, document, publisher) {
        return __awaiter(this, void 0, void 0, function* () {
            const args = {
                documentId: did,
                signature,
                document: JSON.stringify(document),
                publisherAddress: publisher
            };
            try {
                const response = yield this.nevermined.utils.fetch.post(this.getSecretStoreEncryptEndpoint(), decodeURI(JSON.stringify(args)));
                if (!response.ok) {
                    throw new Error('HTTP request failed');
                }
                return yield response.text();
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    encrypt(did, document, method) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = {
                did: did,
                message: document,
                method: method
            };
            try {
                const response = yield this.nevermined.utils.fetch.post(this.getEncryptEndpoint(), decodeURI(JSON.stringify(payload)));
                if (!response.ok) {
                    throw new Error('HTTP request failed');
                }
                return yield response.text();
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    execute(agreementId, computeDid, workflowDid, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const { jwt } = this.nevermined.utils;
            let accessToken;
            const cacheKey = jwt.generateCacheKey(account.getId(), agreementId, workflowDid);
            try {
                if (!jwt.tokenCache.has(cacheKey)) {
                    const grantToken = yield jwt.generateExecuteGrantToken(account, agreementId, workflowDid);
                    accessToken = yield this.fetchToken(grantToken);
                    jwt.tokenCache.set(cacheKey, accessToken);
                }
                else {
                    accessToken = this.nevermined.utils.jwt.tokenCache.get(cacheKey);
                }
                const headers = {
                    Authorization: "Bearer " + accessToken
                };
                const response = yield this.nevermined.utils.fetch.post(this.getExecuteEndpoint(utils_1.noZeroX(agreementId)), undefined, headers);
                if (!response.ok) {
                    throw new Error('HTTP request failed');
                }
                return yield response.json();
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    downloadService(did, account, files, destination, index = -1) {
        return __awaiter(this, void 0, void 0, function* () {
            const { jwt } = this.nevermined.utils;
            let accessToken;
            const cacheKey = jwt.generateCacheKey(account.getId(), did);
            if (!jwt.tokenCache.has(cacheKey)) {
                const grantToken = yield jwt.generateDownloadGrantToken(account, did);
                accessToken = yield this.fetchToken(grantToken);
                jwt.tokenCache.set(cacheKey, accessToken);
            }
            else {
                accessToken = this.nevermined.utils.jwt.tokenCache.get(cacheKey);
            }
            const headers = {
                Authorization: "Bearer " + accessToken
            };
            const filesPromises = files
                .filter((_, i) => index === -1 || i === index)
                .map(({ index: i }) => __awaiter(this, void 0, void 0, function* () {
                const consumeUrl = `${this.getDownloadEndpoint()}/${i}`;
                try {
                    yield this.nevermined.utils.fetch.downloadFile(consumeUrl, destination, i, headers);
                }
                catch (e) {
                    this.logger.error('Error consuming assets');
                    this.logger.error(e);
                    throw e;
                }
            }));
            yield Promise.all(filesPromises);
            return destination;
        });
    }
    computeLogs(agreementId, executionId, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const { jwt } = this.nevermined.utils;
            let accessToken;
            const cacheKey = jwt.generateCacheKey(account.getId(), agreementId, executionId);
            try {
                if (!jwt.tokenCache.has(cacheKey)) {
                    const grantToken = yield jwt.generateComputeGrantToken(account, agreementId, executionId);
                    accessToken = yield this.fetchToken(grantToken);
                    jwt.tokenCache.set(cacheKey, accessToken);
                }
                else {
                    accessToken = this.nevermined.utils.jwt.tokenCache.get(cacheKey);
                }
                const headers = {
                    Authorization: "Bearer " + accessToken
                };
                const response = yield this.nevermined.utils.fetch.get(this.getComputeLogsEndpoint(utils_1.noZeroX(agreementId), utils_1.noZeroX(executionId)), headers);
                if (!response.ok) {
                    throw new Error('HTTP request failed');
                }
                return yield response.text();
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    computeStatus(agreementId, executionId, account) {
        return __awaiter(this, void 0, void 0, function* () {
            const { jwt } = this.nevermined.utils;
            let accessToken;
            const cacheKey = jwt.generateCacheKey(account.getId(), agreementId, executionId);
            try {
                if (!jwt.tokenCache.has(cacheKey)) {
                    const grantToken = yield jwt.generateComputeGrantToken(account, agreementId, executionId);
                    accessToken = yield this.fetchToken(grantToken);
                    jwt.tokenCache.set(cacheKey, accessToken);
                }
                else {
                    accessToken = this.nevermined.utils.jwt.tokenCache.get(cacheKey);
                }
                const headers = {
                    Authorization: "Bearer " + accessToken
                };
                const response = yield this.nevermined.utils.fetch.get(this.getComputeStatusEndpoint(utils_1.noZeroX(agreementId), utils_1.noZeroX(executionId)), headers);
                if (!response.ok) {
                    throw new Error('HTTP request failed');
                }
                return yield response.text();
            }
            catch (e) {
                this.logger.error(e);
                throw new Error('HTTP request failed');
            }
        });
    }
    fetchToken(grantToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.nevermined.utils.fetch.fetch(this.getFetchTokenEndpoint(), {
                method: 'POST',
                body: `grant_type=${encodeURI(this.nevermined.utils.jwt.GRANT_TYPE)}&assertion=${encodeURI(grantToken)}`,
                headers: {
                    'Content-type': 'application/x-www-form-urlencoded',
                }
            });
            if (!response.ok) {
                throw new Error(yield response.text());
            }
            const jsonPayload = yield response.json();
            return jsonPayload.access_token;
        });
    }
}
exports.Gateway = Gateway;
//# sourceMappingURL=Gateway.js.map